/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  Copyright (C) 2010 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */

#if !defined A1_H_INCLUDED
#define A1_H_INCLUDED

/* Keep C++ compilers from getting confused */
#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

#define A1_SUCCESS 0
#define A1_ERROR   1

/* FIXME: Add doxygen comments here! */

  /* ********************************************************************* */
  /*                                                                       */
  /*               Enumerations                                            */
  /*                                                                       */
  /* ********************************************************************* */

  /**
   * \brief Thread support within A1.
   *
   * Implementation details:
   *
   * A1_THREAD_SINGLE does not distinguish between single- and multiple-
   * threaded execution since A1 should not care if multiple threads
   * are present if the others are not making communication calls.
   *
   * A1_THREAD_MATCHED only requires one to lock the generic A1 stack
   * and not any of the communication channels since they are dedicated.
   *
   * A1_THREAD_GENERAL requires locking on the A1 stack as well as the 
   * communication channel(s).  A1 should internally decide the best way
   * to implement this protocol.
   *
   * \note This is different from MPI, which uses SINGLE, SERIALIZED and 
   *       FUNNELED support mechanisms.
   *
   */

  typedef enum
  {
    A1_THREAD_SINGLE   /**< A1 is called from only one thread. */
    A1_THREAD_MATCHED  /**< Each A1 channel is accessed from only one thread. */
    A1_THREAD_GENERAL  /**< Any A1 channel can be accessed from any thread. */
  }
  A1_thread_level;

/**
  * \brief Initializes the Al environment.
  *
  * This routine initializes one or more communication channels that 
  * may be used in the course of a program.
  *
  *
  * \warning This must be the first A1 call made in any code
  *
  * \note This routine is called A1_Initialize for syntactic symmetry with A1_Finalize.
  *
  * \note The reason to give the number of threads at initialization is so that
  *       certain kinds of efficient locking mechanisms will function better in
  *       the context of limited number of threads.
  *
  * \param[out] rc              The error code from initalizing A1
  * \param[in]  A1_thread_level The type of thread support for A1
  * \param[in]  A1_num_threads  The number of threads A1 supports
  * \param[in]  A1_num_channels Number of channels to initialize
  * \param[in]  A1_channels[]   Array of channels to initialize
  *
  * \see A1_thread_level, a1_channel_t
  *
  * \ingroup MANAGEMENT
  */

int A1_Initialize(int A1_thread_level, 
                  int A1_num_threads, 
                  int A1_num_channels, 
                  a1_channel_t A1_channels[]);

/**
  * \brief Terminates the A1 environment normally.
  *
  * \warning This must be the last A1 call made in any code unless A1_Abort is called instead.
  *
  * \param[out] rc    The error code from terminating A1.  Not sure what one would do with this.
  * \param[in]  none  Proper termination should not require additional information.
  *
  * \see A1_Initialize, A1_Abort
  *
  * \ingroup MANAGEMENT
  */

int A1_Finalize(void);

/**
  * \brief Terminates the A1 environment abnormally.
  *
  * \warning This must be the last A1 call made in any code unless A1_Finalize is called instead.
  *
  * \param[out] rc            The error code from terminating A1.  Not sure what one would do with this.
  * \param[in]  error_code    The error code to be returned to the submitting environment.
  * \param[in]  error_message Text string to print to stderr upon termination.
  *
  * \see A1_Initialize, A1_Finalize
  *
  * \ingroup MANAGEMENT
  */

int A1_Abort(int error_code, char error_message[]);

/* FIXME: More API functions to come */


/* A1_VERSION is the version string. A1_NUMVERSION is the
 * numeric version that can be used in numeric comparisons.
 *
 * A1_VERSION uses the following format:
 * Version: [MAJ].[MIN].[REV][EXT][EXT_NUMBER]
 * Example: 1.0.7rc1 has
 *          MAJ = 1
 *          MIN = 0
 *          REV = 7
 *          EXT = rc
 *          EXT_NUMBER = 1
 *
 * A1_NUMVERSION will convert EXT to a format number:
 *          ALPHA (a) = 0
 *          BETA (b)  = 1
 *          RC (rc)   = 2
 *          PATCH (p) = 3
 * Regular releases are treated as patch 0
 *
 * Numeric version will have 1 digit for MAJ, 2 digits for MIN, 2
 * digits for REV, 1 digit for EXT and 2 digits for EXT_NUMBER. So,
 * 1.0.7rc1 will have the numeric version 10007201.
 */
#define A1_VERSION "@A1_VERSION@"
#define A1_NUMVERSION @A1_NUMVERSION@

#define A1_RELEASE_TYPE_ALPHA  0
#define A1_RELEASE_TYPE_BETA   1
#define A1_RELEASE_TYPE_RC     2
#define A1_RELEASE_TYPE_PATCH  3

#define A1_CALC_VERSION(MAJOR, MINOR, REVISION, TYPE, PATCH) \
    (((MAJOR) * 10000000) + ((MINOR) * 100000) + ((REVISION) * 1000) + ((TYPE) * 100) + (PATCH))

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* A1_H_INCLUDED */
