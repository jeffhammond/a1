/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  Copyright (C) 2010 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */

#if !defined A1_H_INCLUDED
#define A1_H_INCLUDED

/* Keep C++ compilers from getting confused */
#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

#define A1_SUCCESS 0
#define A1_ERROR   1

/** @file a1.h.in */

/*! \addtogroup a1 A1 Public Interface
 * @{
 */


/* ********************************************************************* */
/*                                                                       */
/*               Enumerations                                            */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Thread support within A1.
 *
 * Implementation details:
 *
 * A1_THREAD_SINGLE, A1_THREAD_FUNNELED and A1_THREAD_SERIALIZED have
 * the same meaning as the MPI descriptors of similar name.
 *
 * A1_THREAD_MATCHED only requires one to lock the generic A1 stack
 * and not any of the memory types since they are dedicated.
 *
 * A1_THREAD_GENERAL requires locking on the A1 stack as well as the
 * memory type(s).  A1 should internally decide the best way to implement 
 * this protocol.
 *
 */

typedef enum
{
    A1_THREAD_SINGLE,       /**< There is only one thread present. */
    A1_THREAD_FUNNELED,     /**< There are multiple threads present but 
                                 only the main thread makes A1 calls. */
    A1_THREAD_SERIALIZED,   /**< There are multiple threads present and each 
                                 can make A1 calls, but never simultaneously. */
    A1_THREAD_MATCHED,      /**< Each A1 memory type is accessed from only one thread. 
                                 For example, one thread communicates remotely via 
                                 the network and another communicates with a GPU. */
    A1_THREAD_GENERAL       /**< Any A1 memtype can be accessed from any thread. */
}
    A1_thread_level;

typedef enum
{
    A1_INT32,         /**< int32  */
    A1_INT64,         /**< int64  */
    A1_UINT32,        /**< uint32 */
    A1_UINT64,        /**< uint64 */
    A1_FLOAT,         /**< single-precision */
    A1_DOUBLE,        /**< double-precision */
}
    A1_datatype;


/* ********************************************************************* */
/*                                                                       */
/*               A1 data structures                                      */
/*                                                                       */
/* ********************************************************************* */

/* FIXME: What is the type for A1_memtype_t. Adding a temporary handle here. */
typedef int A1_memtype_t;

/* FIXME: What is the type for A1_group_t. Adding a temporary handle here. */
typedef int A1_group_t;


/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - Helper Functions                      */
/*                                                                       */
/* ********************************************************************* */

/**
  * \brief Returns global rank of the process calling it.
  *
  * \param[out] rc          Number of cycles from an arbitrary time in the past.
  *
  * \see
  *
  * \ingroup INFORMATION
  */

unsigned long long A1_Time();

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - Process Information                   */
/*                                                                       */
/* ********************************************************************* */

/**
  * \brief Returns global rank of the process calling it. 
  *
  * \param[out] rank          Global rank of the process.
  *
  * \see 
  *
  * \ingroup INFORMATION 
  */

void A1_Rank(int* rank);

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - management                            */
/*                                                                       */
/* ********************************************************************* */

/**
  * \brief Initializes the Al environment.
  *
  * This routine initializes one or more memory types that 
  * may be used in the course of a program.
  *
  * \warning This must be the first A1 call made in any code
  *
  * \note This routine is called A1_Initialize for syntactic symmetry with A1_Finalize.
  *
  * \note The reason to give the number of threads at initialization is so that
  *       certain kinds of efficient locking mechanisms will function better in
  *       the context of limited number of threads.
  *
  * \param[out] rc               The error code from initalizing A1
  * \param[in]  A1_thread_level  The type of thread support for A1
  * \param[in]  A1_num_threads   The number of threads A1 supports
  * \param[in]  A1_num_memtypes  Number of memory types to initialize
  * \param[in]  A1_memtypes[]    Array of memory types to initialize
  *
  * \see A1_thread_level, A1_memtype_t
  *
  * \ingroup MANAGEMENT
  */

int A1_Initialize(int A1_thread_level, 
                  int A1_num_threads, 
                  int A1_num_memtypes, 
                  A1_memtype_t A1_memtypes[]);

/**
  * \brief Terminates the A1 environment normally.
  *
  * \warning This must be the last A1 call made in any code unless A1_Abort is called instead.
  *
  * \param[out] rc    The error code from terminating A1.  Not sure what one would do with this.
  * \param[in]  none  Proper termination should not require additional information.
  *
  * \see A1_Initialize, A1_Abort
  *
  * \ingroup MANAGEMENT
  */

int A1_Finalize(void);

/**
  * \brief Terminates the A1 environment abnormally.
  *
  * \warning This must be the last A1 call made in any code unless A1_Finalize is called instead.
  *
  * \param[out] rc            The error code from terminating A1.  Not sure what one would do with this.
  * \param[in]  error_code    The error code to be returned to the submitting environment.
  * \param[in]  error_message Text string to print to stderr upon termination.
  *
  * \see A1_Initialize, A1_Finalize
  *
  * \ingroup MANAGEMENT
  */

int A1_Abort(int error_code, char error_message[]);

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - memory                                */
/*                                                                       */
/* ********************************************************************* */

/**
  * \brief A collective operation to allocate memory to be used in context of A1 copy operations.
  *
  * \note Memory allocated with this function will be properly aligned for the architecture.
  *
  * \warning Memory allocated with this function must be freed by A1_Free.
  *
  * \param[out] rc            The error code.
  * \param[out] ptr[]         Array of pointers, each representing a region a process.
  * \param[in]  bytes         The amount of memory requested.
  *
  * \see A1_Free
  *
  * \ingroup MEMORY
  */

int A1_Malloc(void* ptr[], int bytes);


/**
  * \brief A collective operation to free memory allocated by an A1_Malloc call.
  *
  * \param[out] rc            The error code.
  * \param[in]  ptr           Pointer to the allocated memory.
  *
  * \see A1_Exchange_segments
  *
  * \ingroup MEMORY
  */

int A1_Free(void* ptr);

/**
  * \brief A local operation to allocate memory to be used in context of A1 copy operations.
  *
  * \note Memory allocated with this function will be properly aligned for the architecture.
  *
  * \warning Memory allocated with this function must be freed by A1_Free_segment.
  *
  * \param[out] rc            The error code.
  * \param[out] ptr           Pointer to memory.
  * \param[in]  bytes         The amount of memory requested.
  *
  * \see A1_Free_segment, A1_Register_segment
  *
  * \ingroup MEMORY
  */

int A1_Alloc_segment(void** pointer, int bytes);

/**
  * \brief A local operation to register memory to be used in context of A1 copy operations.
  *
  * \note Memory allocated with this function will be tested for proper alignment and return
  *       an error if alignment checking has been disabled and the pointer is not properly aligned.
  *
  * \note A1_Register_segment will check for valid allocation of the memory provided,
  *       potentially by writing "\0" to all bytes.
  *
  * \param[out] rc            The error code.
  * \param[in]  ptr           Pointer to memory.
  * \param[in]  bytes         The amount of memory provided.
  *
  * \see A1_Alloc_segment, A1_Free_segment
  *
  * \ingroup MEMORY
  */

int A1_Register_segment(void** pointer, int bytes);

/**
  * \brief A local operation to free memory allocated by A1_Alloc_segment.
  *
  * \warning It is erroneous to attempt to free memory not allocated by A1_Alloc_segment.
  *
  * \param[out] rc            The error code.
  * \param[in] ptr           Pointer to memory.
  *
  * \see A1_Alloc_segment, A1_Register_segment
  *
  * \ingroup MEMORY
  */

int A1_Free_segment(void* pointer);

/**
  * \brief A collective operation to allocate memory to be used in context of A1 copy operations.
  *
  * \note The size specified at each process should be the same.
  *
  * \param[out] rc            The error code.
  * \param[in]  group         Group of processes within which the pointer list is exchanged.
  * \param[in]  ptr           Pointer array. Each one points to memory allocated at one process, in order of ranks. 
  * \param[in]  bytes         The size of memory allocated at each process.
  *
  * \see A1_Release_segments
  *
  * \ingroup MEMORY
  */
int A1_Exchange_segments(A1_group_t* group, void* ptr[], int bytes);

/**
  * \brief A collective operation to free memory allocated by an A1_Malloc call.
  *
  * \param[out] rc            The error code.
  * \param[in]  group         Group of processes within which the pointer list was exchanged.
  * \param[in]  ptr           Pointer to the allocated memory.
  *
  * \see A1_Exchange_segments
  *
  * \ingroup MEMORY
  */

int A1_Release_segments(A1_group_t* group, void* ptr);

/* FIXME: More API functions to come */

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - copy operations                        */
/*                                                                        */
/* ********************************************************************** */

/**
  * \brief Blocking copy of contiguous data from local memory to remote memory.
  *
  * \param[out] rc            The error code.
  * \param[in]  target        Rank of the remote process.
  * \param[in]  source_ptr    Starting address in the (local) source memory.
  * \param[in]  target_ptr    Starting address in the (remote) target memory.
  * \param[in]  bytes         Amount of data to transfer, in bytes.
  * 
  * \see A1_Get, A1_Copy, A1_PutAcc
  *
  * \ingroup MEMORY
  */

int A1_Put(int target, void* source_ptr, void* target_ptr, int bytes);

/**
  * \brief Blocking copy of contiguous data from local memory to remote memory.
  *
  * \param[out] rc              The error code.
  * \param[in]  target          Rank of the remote process.
  * \param[in]  source_ptr      Starting address in the (local) source memory.
  * \param[in]  src_stride_ar   Array of stride distances at source, in bytes.
  * \param[in]  target_ptr      Starting address in the (remote) target memory.
  * \param[in]  trg_stride_ar   Array of stride distances at target, in bytes.
  * \param[in]  count           Block size in each dimension, in bytes.
  * \param[in]  stride_levels   The number of levels of stride.
  *
  * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
  *
  * \ingroup MEMORY
  */

int A1_PutS(int target, void* source_ptr, int *src_stride_ar, void* target_ptr,\
         int *trg_stride_ar, int *count, int stride_levels);

/**
  * \brief Blocking accumulate of contiguous data from local memory onto remote memory.
  *
  * \param[out] rc            The error code.
  * \param[in]  target        Rank of the remote process.
  * \param[in]  source_ptr    Starting address in the (local) source memory.
  * \param[in]  target_ptr    Starting address in the (remote) target memory.
  * \param[in]  bytes         Amount of data to transfer, in bytes.
  * \param[in]  a1_type       Amount of data to transfer, in bytes.
  * \param[in]  scaling       Factor for scaling source
  *
  * \see A1_Put, A1_Copy, A1_CopyAcc
  *
  * \ingroup MEMORY
  */

int A1_PutAcc(int target, void* source_ptr, void* target_ptr, int bytes, A1_datatype a1_type, void* scaling);

/**
  * \brief Blocking copy of contiguous data from remote memory to local memory.
  *
  * \param[out] rc            The error code.
  * \param[in]  target        Rank of the remote process.
  * \param[in]  source_ptr    Starting address in the (remote) source memory.
  * \param[in]  target_ptr    Starting address in the (local) target memory.
  * \param[in]  bytes         Amount of data to transfer, in bytes.
  * 
  * \see A1_Put, A1_Copy
  *
  * \ingroup MEMORY
  */

int A1_Get(int target, void* source_ptr, void* target_ptr, int bytes);

/**
  * \brief Blocking copy of contiguous data from remote memory to local memory.
  *
  * \param[out] rc              The error code.
  * \param[in]  target          Rank of the remote process.
  * \param[in]  source_ptr      Starting address in the (remote) source memory.
  * \param[in]  src_stride_ar   Array of stride distances at (remote process) source, in bytes.
  * \param[in]  target_ptr      Starting address in the (local) target memory.
  * \param[in]  trg_stride_ar   Array of stride distances at (local process) target, in bytes.
  * \param[in]  count           Block size in each dimension, in bytes.
  * \param[in]  stride_levels   The number of levels of stride.
  *
  * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
  *
  * \ingroup MEMORY
  */

int A1_GetS(int target, void* source_ptr, int *src_stride_ar, void* target_ptr,\
         int *trg_stride_ar, int *count, int stride_levels); 

/**
  * \brief Blocking accumulate of contiguous data from remote memory onto local memory.
  *
  * \param[out] rc            The error code.
  * \param[in]  target        Rank of the remote process.
  * \param[in]  source_ptr    Starting address in the (remote) source memory.
  * \param[in]  target_ptr    Starting address in the (local) target memory.
  * \param[in]  bytes         Amount of data to transfer, in bytes.
  * \param[in]  a1_type       Amount of data to transfer, in bytes.
  * \param[in]  scaling       Factor for scaling source
  *
  * \see A1_Put, A1_Copy
  *
  * \ingroup MEMORY
  */

int A1_GetAcc(int target, void* source_ptr, void* target_ptr, int bytes, A1_datatype a1_type, void* scaling);

/**
  * \brief Blocking copy of contiguous data from remote memory to remote memory.
  *
  * \param[out] rc            The error code.
  * \param[in]  source        Rank of the (remote) source process.
  * \param[in]  target        Rank of the (remote) target process.
  * \param[in]  source_ptr    Starting address in the (remote) source memory.
  * \param[in]  target_ptr    Starting address in the (remote) target memory.
  * \param[in]  bytes         Amount of data to transfer, in bytes.
  *
  * \see A1_Put, A1_Get
  *
  * \ingroup MEMORY
  */

int A1_Copy(int source, int target, void* source_ptr, void* target_ptr, int bytes);

/**
  * \brief Blocking accumulate of contiguous data from remote memory onto remote memory.
  *
  * \param[out] rc            The error code.
  * \param[in]  source        Rank of the (remote) source process.
  * \param[in]  target        Rank of the (remote) target process.
  * \param[in]  source_ptr    Starting address in the (remote) source memory.
  * \param[in]  target_ptr    Starting address in the (remote) target memory.
  * \param[in]  bytes         Amount of data to transfer, in bytes.
  * \param[in]  a1_type       Amount of data to transfer, in bytes.
  * \param[in]  scaling       Factor for scaling source
  *
  * \see A1_Put, A1_Get
  *
  * \ingroup MEMORY
  */

int A1_CopyAcc(int source, int target, void* source_ptr, void* target_ptr, int bytes, A1_datatype a1_type, void* scaling);

/* FIXME: More API functions to come */

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - completion and synchronization         */
/*                                                                        */
/* ********************************************************************** */

/**
  * \brief On return, this call ensures that all processes within the entire group
  *        have reached this point in the program.
  *
  *        This operation is collective and blocking.
  *
  * \param[in] group          Group of processes to synchronize.
  *
  * \see A1_Flush, A1_AllFlush, A1_Sync.
  *
  * \ingroup SYNCHRONIZATION
  */

void A1_Barrier(A1_group_t* group);

/**
  * \brief On return, this call ensure that all blocking put or accumulate operations
  *        issued to a particular process are complete remotely.
  *
  *        This operation is local and blocking.
  *
  * \param[in]  proc          Rank of the remote process.
  *
  * \see A1_Flush_group, A1_Sync
  *
  * \ingroup COMPLETION 
  */

void A1_Flush(int proc);

/**
  * \brief On return, this call ensures that all outstanding blocking put or accumulate
  *        operations are complete remotely to the processes given in the list.
  *
  *        This operation is local and blocking.
  *
  * \param[in] list           Vector of processes to flush against.
  *
  * \see A1_Flush, A1_Flush_group
  *
  * \ingroup COMPLETION
  */

void A1_Flush_many(int list[]);

/**
  * \brief On return, this call ensures that all outstanding blocking put or accumulate 
  *        operations are complete remotely to the processes in the group.
  *
  *        This operation is local and blocking.
  *
  * \param[in] group          Group of processes to flush against.
  *
  * \see A1_Flush, A1_Sync
  *
  * \ingroup COMPLETION 
  */

void A1_Flush_group(A1_group_t* group);

/**
  * \brief On return, this call ensures that all outstanding blocking put or accumulate
  *        operations are complete remotely to all processes.
  *
  *        This operation is local and blocking.
  *
  * \see A1_Flush_group, A1_Sync
  *
  * \ingroup COMPLETION
  */

void A1_Flush_all();

/**
  * \brief On return, this call ensures that all outstanding blocking put or accumulate
  *        operations are complete remotely within the entire group.
  *
  *        This operation is collective and blocking.  It comes the effect of
  *        A1_Flush_group called from every process in the group followed by A1_Barrier.
  *
  * \param[in] group          Group of processes to synchronize.
  *
  * \see A1_Flush, A1_Flush_list, A1_FLush_group, A1_Flush_all.
  *
  * \ingroup SYNCHRONIZATION
  */

void A1_Sync(A1_group_t* group);

/* FIXME: More API functions to come */

/*! @} */

/* A1_VERSION is the version string. A1_NUMVERSION is the
 * numeric version that can be used in numeric comparisons.
 *
 * A1_VERSION uses the following format:
 * Version: [MAJ].[MIN].[REV][EXT][EXT_NUMBER]
 * Example: 1.0.7rc1 has
 *          MAJ = 1
 *          MIN = 0
 *          REV = 7
 *          EXT = rc
 *          EXT_NUMBER = 1
 *
 * A1_NUMVERSION will convert EXT to a format number:
 *          ALPHA (a) = 0
 *          BETA (b)  = 1
 *          RC (rc)   = 2
 *          PATCH (p) = 3
 * Regular releases are treated as patch 0
 *
 * Numeric version will have 1 digit for MAJ, 2 digits for MIN, 2
 * digits for REV, 1 digit for EXT and 2 digits for EXT_NUMBER. So,
 * 1.0.7rc1 will have the numeric version 10007201.
 */
#define A1_VERSION "@A1_VERSION@"
#define A1_NUMVERSION @A1_NUMVERSION@

#define A1_RELEASE_TYPE_ALPHA  0
#define A1_RELEASE_TYPE_BETA   1
#define A1_RELEASE_TYPE_RC     2
#define A1_RELEASE_TYPE_PATCH  3

#define A1_CALC_VERSION(MAJOR, MINOR, REVISION, TYPE, PATCH) \
    (((MAJOR) * 10000000) + ((MINOR) * 100000) + ((REVISION) * 1000) + ((TYPE) * 100) + (PATCH))

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* A1_H_INCLUDED */
