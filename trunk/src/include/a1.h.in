/* -*- Mode: C; c-basic-offset:4 ; -*- */
/*
 *  Copyright (C) 2010 by Argonne National Laboratory.
 *      See COPYRIGHT in top-level directory.
 */

#if !defined A1_H_INCLUDED
#define A1_H_INCLUDED

/* Keep C++ compilers from getting confused */
#if defined(__cplusplus)
extern "C"
{
#endif /* __cplusplus */

#define A1_SUCCESS 0
#define A1_ERROR   1

#define A1_TRUE  1
#define A1_FALSE 0

/** @file a1.h.in */

/*! \addtogroup a1 A1 Public Interface
 * @{
 */

/* ********************************************************************* */
/*                                                                       */
/*               Enumerations                                            */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Thread support within A1.
 *
 * Implementation details:
 *
 * A1_THREAD_SINGLE, A1_THREAD_FUNNELED and A1_THREAD_SERIALIZED have
 * the same meaning as the MPI descriptors of similar name.
 *
 * A1_THREAD_MATCHED only requires one to lock the generic A1 stack
 * and not any of the channels they are dedicated.
 *
 * A1_THREAD_GENERAL requires locking on the A1 stack as well as the
 * channel(s).  A1 should internally decide the best way to implement
 * this protocol.
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_THREAD_SINGLE, /**< There is only one thread present. */
    A1_THREAD_FUNNELED, /**< There are multiple threads present but
     only the main thread makes A1 calls. */
    A1_THREAD_SERIALIZED, /**< There are multiple threads present and each
     can make A1 calls, but never simultaneously. */
    A1_THREAD_MATCHED, /**< Each A1 channel is accessed from only one thread.
     For example, one thread communicates remotely via
     the network and another communicates with a GPU. */
    A1_THREAD_GENERAL
/**< Any A1 channel can be accessed from any thread. */
} A1_thread_level;

/**
 * \brief Datatype support within A1.
 *
 * \note A1 does not support complex numbers yet.  This is okay because
 *       imaginary numbers don't exist, by definition :-)
 *
 * \ingroup ENUMS
 *
 */

typedef enum
{
    A1_INT32, /**< int32  */
    A1_INT64, /**< int64  */
    A1_UINT32, /**< uint32 */
    A1_UINT64, /**< uint64 */
    A1_FLOAT, /**< single-precision */
    A1_DOUBLE,
/**< double-precision */
} A1_datatype_t;

/* ********************************************************************* */
/*                                                                       */
/*               A1 data structures                                      */
/*                                                                       */
/* ********************************************************************* */

/* FIXME: What is the type for A1_group_t. Adding a temporary structure here. */
typedef struct A1_group
{

} A1_group_t;

A1_group_t a1_group_world;

#define A1_GROUP_WORLD &a1_group_world

/**
 * \brief A1 non-blocking handle status boolean (A1_TRUE and A1_FALSE).
 *
 * \see A1_Test_handle, A1_Test_handle_list
 *
 * \ingroup TYPEDEFS
 *
 */

typedef int A1_bool_t;

/**
 * \brief A1 non-blocking handle type.
 *
 * \see A1_Test_handle, A1_Test_handle_list, A1_Wait_handle, A1_Wait_handle_list
 *
 * \ingroup TYPEDEFS
 *
 */

typedef uintptr_t A1_handle_t;


/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - Helper Functions                      */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Timer in units of cycles.
 *
 * \warning This function is not guaranteed to produce correct results for
 *          arbitrarily-long durations.
 *
 * \param[out] rc          Number of cpu clock cycles from an arbitrary time in the past.
 *
 * \see A1_Time_seconds
 *
 * \ingroup INFORMATION
 */

unsigned long long A1_Time_cycles();

/**
 * \brief Timer in units of seconds.
 *
 *
 * \param[out] rc          Number of seconds from an arbitrary time in the past.
 *
 * \see A1_Time_cycles
 *
 * \ingroup INFORMATION
 */

double A1_Time_seconds();

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - Process Information                   */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Returns process rank relative to the group base of the process calling it.
 *
 * \note Jeff hates MPI-style function style where return value is an
 *       argument passed by reference for the sake of Fortran compatibility
 *       (or whatever their reason is).
 *
 * \see A1_Node_id, A1_Process_total
 *
 * \ingroup INFORMATION
 */

int A1_Process_id(A1_group_t* group);

/**
 * \brief Returns total number of processes in a group.
 *
 * \note Jeff hates MPI-style function style where return value is an
 *       argument passed by reference for the sake of Fortran compatibility
 *       (or whatever their reason is).
 *
 * \see A1_Process_id, A1_Node_total
 *
 * \ingroup INFORMATION
 */

int A1_Process_total(A1_group_t* group);

/**
 * \brief Returns node rank relative to the group base of the process calling it.
 *
 * \note Jeff hates MPI-style function style where return value is an argument
 *       passed by reference for the sake of Fortran compatibility.
 *
 * \see A1_Process_id, A1_Node_total
 *
 * \ingroup INFORMATION
 */

int A1_Node_id(A1_group_t* group);

/**
 * \brief Returns total number of nodes in a group.
 *
 * \note Jeff hates MPI-style function style where return value is an argument
 *       passed by reference for the sake of Fortran compatibility.
 *
 * \see A1_Node_id, A1_Process_total
 *
 * \ingroup INFORMATION
 */

int A1_Node_total(A1_group_t* group);

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - management                            */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief Initializes the Al environment.
 *
 * \warning This must be the first A1 call made in any code.
 *
 * \note Unlike MPI, A1_Initialize may be called many times and is thread-safe.
 *       Improper use of A1_Initialize (calling it more than once) shall be
 *       indicated by a non-zero error code and potentially warnings in
 *       stderr.
 *
 * \note Implementation detail: we need global variable indicated where or not
 *       A1 is alive or not to make this function thread-safe.
 *
 * \note This routine is called A1_Initialize for syntactic symmetry with
 *       A1_Finalize and because of Jeff's schadenfreude toward Pavan.
 *
 * \param[out] rc               The error code from initializing A1
 * \param[in]  A1_thread_level  The type of thread support for A1
 *
 * \see A1_thread_level
 *
 * \ingroup MANAGEMENT
 */

int A1_Initialize(int A1_thread_level);

/**
 * \brief Terminates the A1 environment normally.
 *
 * \warning This must be the last A1 call made in any code unless A1_Abort is called instead.
 *
 * \note Unlike MPI, A1_Finalize may be called many times and is thread-safe.
 *       Improper use of A1_Finalize (calling it more than once) shall be
 *       indicated by a non-zero error code and potentially warnings in
 *       stderr.
 *
 * \note Implementation detail: we need global variable indicated where or not
 *       A1 is alive or not to make this function thread-safe.
 *
 * \param[out] rc    The error code from terminating A1.
 *
 * \see A1_Initialize, A1_Abort
 *
 * \ingroup MANAGEMENT
 */

int A1_Finalize(void);

/**
 * \brief Terminates the A1 environment abnormally.
 *
 * \warning This must be the last A1 call made in any code unless A1_Finalize is called instead.
 *
 * \param[out] rc            The error code from terminating A1.  Not sure what one would do with this.
 * \param[in]  error_code    The error code to be returned to the submitting environment.
 * \param[in]  error_message Text string to print to stderr upon termination.
 *
 * \see A1_Initialize, A1_Finalize
 *
 * \ingroup MANAGEMENT
 */

int A1_Abort(int error_code, char error_message[]);

/* ********************************************************************* */
/*                                                                       */
/*               A1 external API - memory                                */
/*                                                                       */
/* ********************************************************************* */

/**
 * \brief A local operation to allocate memory to be used in context of A1 copy operations.
 *
 * \note Memory allocated with this function will be properly aligned for the architecture.
 *
 * \warning Memory allocated with this function must be freed by A1_Free_segment.
 *
 * \param[out] rc            The error code.
 * \param[out] ptr           Pointer to memory.
 * \param[in]  bytes         The amount of memory requested.
 *
 * \see A1_Free_segment, A1_Register_segment
 *
 * \ingroup MEMORY
 */

int A1_Alloc_segment(void** pointer, int bytes);

/**
 * \brief A local operation to free memory allocated by A1_Alloc_segment.
 *
 * \warning It is erroneous to attempt to free memory not allocated by A1_Alloc_segment.
 *
 * \param[out] rc            The error code.
 * \param[in] ptr           Pointer to memory.
 *
 * \see A1_Alloc_segment, A1_Register_segment
 *
 * \ingroup MEMORY
 */

int A1_Free_segment(void* pointer);

/**
 * \brief A local operation to register memory to be used in context of A1 copy operations.
 *
 * \note This call is not necessary for memory allocated with A1_Alloc_segment.
 *
 * \note Memory allocated with this function will be tested for proper alignment and return
 *       an error if alignment checking has been disabled and the pointer is not properly aligned.
 *
 * \note A1_Register_segment will check for valid allocation of the memory provided,
 *       potentially by writing "\0" to all bytes.
 *
 * \note This call may not work in all contexts.  For example, CUDA provides no API call to
 *       register pre-allocated memory.  A truly portable A1 program must not call this
 *       function.
 *
 * \param[out] rc            The error code.
 * \param[in]  ptr           Pointer to memory.
 * \param[in]  bytes         The amount of memory provided.
 *
 * \see A1_Alloc_segment, A1_Free_segment
 *
 * \ingroup MEMORY
 */

int A1_Register_segment(void** pointer, int bytes);

/**
 * \brief A collective operation to allocate memory to be used in context of A1 copy operations.
 *
 * \note There is no local de-registration call because that could lead to erroneous programs.
 *       De-registration can only be effected by a call to A1_Release_segments, which is collective.
 *
 * \param[out] rc            The error code.
 * \param[in]  group         Group of processes within which the pointer list is exchanged.
 * \param[in]  ptr           Pointer array. Each one points to memory allocated at one process, in order of ranks.
 * \param[in]  bytes         The size of memory allocated at each process.
 *
 * \see A1_Release_segments
 *
 * \ingroup MEMORY
 */
int A1_Exchange_segments(A1_group_t* group, void* *ptr, int bytes);

/**
 * \brief A collective operation to invalidate and de-register memory segments
 *        associated with an A1_Exchange_segments call.
 *
 * \param[out] rc            The error code.
 * \param[in]  group         Group of processes within which the pointer list was exchanged.
 * \param[in]  ptr           Pointer to the allocated memory.
 *
 * \see A1_Exchange_segments
 *
 * \ingroup MEMORY
 */

int A1_Release_segments(A1_group_t* group, void* ptr);

/**
 * \brief Initializes the give non-blocking handle.
 *
 * \param[in] handle      Non-blocking handle upon which to be waited.
 *
 * \see A1_handle_t, A1_Wait_handle_list, A1_Test_handle
 *
 * \ingroup MEMORY
 */

int A1_Init_handle(A1_handle_t *handle);

/* FIXME: More API functions to come */

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - data transfer operations               */
/*                                                                        */
/* ********************************************************************** */

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 *
 * \see A1_PutS, A1_PutV, A1_MultiPut, A1_MultiPutS, A1_MultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_Put(int target,
           void* source_ptr,
           void* target_ptr,
           int bytes);

/**
 * \brief Non-Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[out] handle        Opaque handle for the request
 *
 * \see A1_NbPutS, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPut(int target,
            void* source_ptr,
            void* target_ptr,
            int bytes,
            A1_handle_t *handle);

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \note A1_MultiPut can be used for single-target non-contiguous put as well,
 *       but the implementation may be far from optimal relative to A1_PutS
 *       and A1_PutV.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  targets       Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting addresses in the (local) source memory.
 * \param[in]  target_ptr    Vector of starting addresses in the (remote) target memory.
 * \param[in]  bytes         Vector of quantity of data to transfer in bytes.
 *
 * \see A1_Put, A1_PutS, A1_PutV, A1_MultiPutS, A1_MultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiPut(int count,
                int *targets,
                void* *source_ptr,
                void* *target_ptr,
                int *bytes);

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 *
 * \see A1_Put, A1_PutV, A1_MultiPut, A1_MultiPutS, A1_MultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutS(int target,
            int stride_levels,
            int *block_sizes,
            void* source_ptr,
            int *src_stride_ar,
            void* target_ptr,
            int *trg_stride_ar);

/**
 * \brief Non-Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 * \param[out] handle        Opaque A1 handle
 *
 * \see A1_NbPut, A1_NbPutV, A1_NbMultiPut, A1_NbMultiPutS, A1_NbMultiPutV
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutS(int target,
            int stride_levels,
            int *block_sizes,
            void* source_ptr,
            int *src_stride_ar,
            void* target_ptr,
            int *trg_stride_ar,
            A1_handle_t *handle);

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \note This call must be use the same stride-level across all targets.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  targets         Vector of remote process ranks.
 * \param[in]  block_sizes     Vector of block sizes in each dimension in bytes.
 * \param[in]  stride_levels   Number of levels of stride.
 * \param[in]  source_ptr      Vector of starting in the (local) source memory.
 * \param[in]  src_stride_ar   Vector of arrays of stride distances at source in bytes.
 * \param[in]  target_ptr      Vector of starting in the (remote) target memory.
 * \param[in]  trg_stride_ar   Vector of arrays of stride distances at target in bytes.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiPutS(int count,
                 int *targets,
                 int stride_levels,
                 int* *block_sizes,
                 void* source_ptr,
                 int *src_stride_ar,
                 void* target_ptr,
                 int *trg_stride_ar);

/**
 * \brief Blocking accumulate of contiguous data from local memory onto remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[in]  a1_type       Datatype of buffer and scaling factor.
 * \param[in]  scaling       Factor for scaling source
 *
 * \see A1_Put, A1_Copy, A1_CopyAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutAcc(int target,
              void* source_ptr,
              void* target_ptr,
              int bytes,
              A1_datatype_t a1_type,
              void* scaling);

/**
 * \brief Non-Blocking accumulate of contiguous data from local memory onto remote memory.
 * 
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (local) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[in]  a1_type       Datatype of buffer and scaling factor.
 * \param[in]  scaling       Factor for scaling source
 * \param[out] handle        Opaque A1 handle 
 *
 * \see A1_Put, A1_Copy, A1_CopyAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutAcc(int target,
              void* source_ptr,
              void* target_ptr,
              int bytes,
              A1_datatype_t a1_type,
              void* scaling,
              A1_handle_t *handle);

/**
 * \brief Blocking accumulate of contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  block_sizes     Block size in each dimension in bytes.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 *
 * \see A1_Put, A1_PutS, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_PutAccS(int target,
               int stride_levels,
               int *block_sizes,
               void* source_ptr,
               int *src_stride_ar,
               void* target_ptr,
               int *trg_stride_ar,
               A1_datatype_t a1_type,
               void* scaling);

/**
 * \brief Non-Blocking accumulate of contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[in]  block_sizes     Block size in each dimension in bytes.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_Put, A1_PutS, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbPutAccS(int target,
               int stride_levels,
               int *block_sizes,
               void* source_ptr,
               int *src_stride_ar,
               void* target_ptr,
               int *trg_stride_ar,
               A1_datatype_t a1_type,
               void* scaling,
               A1_handle_t *handle);

/**
 * \brief Blocking copy of contiguous data from remote memory to local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (local) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 *
 * \see A1_NbGet, A1_Put, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_Get(int target, void* source_ptr, void* target_ptr, int bytes);

/**
 * \brief Non-Blocking copy of contiguous data from remote memory to local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (local) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[out] handle        Opaque handle for the request
 *
 * \see A1_Get, A1_Put, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbGet(int target, 
             void* source_ptr, 
             void* target_ptr, 
             int bytes,
             A1_handle_t* handle);

/**
 * \brief Blocking copy of contiguous data from remote memory onto local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  count         Number of operations to be performed
 * \param[in]  target        Vector of remote process ranks.
 * \param[in]  source_ptr    Vector of starting address in the (remote) source memory.
 * \param[in]  target_ptr    Vector of starting address in the (local) target memory.
 * \param[in]  bytes         Vector of data to transfer from each target in bytes.
 *
 * \see A1_Get, A1_MultiPut, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiGet(int count,
                int *target,
                void* *source_ptr,
                void* *target_ptr,
                int *bytes);

/**
 * \brief Blocking copy of strided data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (remote) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at (remote process) source in bytes.
 * \param[in]  target_ptr      Starting address in the (local) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at (local process) target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_GetS(int target,
            int stride_levels,
            int *block_sizes,
            void* source_ptr,
            int *src_stride_ar,
            void* target_ptr,
            int *trg_stride_ar);

/**
 * \brief Non-Blocking copy of strided data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (remote) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at (remote process) source in bytes.
 * \param[in]  target_ptr      Starting address in the (local) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at (local process) target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 * \param[out] handle          Opaque A1 handle
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_NbGetS(int target,
            int stride_levels,
            int *block_sizes,
            void* source_ptr,
            int *src_stride_ar,
            void* target_ptr,
            int *trg_stride_ar,
            A1_handle_t *handle);

/**
 * \brief Blocking copy of stided data from remote memory to local memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  count           Number of operations to be performed
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (remote) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at (remote process) source in bytes.
 * \param[in]  target_ptr      Starting address in the (local) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at (local process) target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_MultiGetS(int target_count,
                 int *target,
                 int stride_levels,
                 int **count,
                 void* *source_ptr,
                 int **src_stride_ar,
                 void* *target_ptr,
                 int **trg_stride_ar);

/**
 * \brief Blocking accumulate of contiguous data from remote memory onto local memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  target        Rank of the remote process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (local) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[in]  a1_type       Amount of data to transfer in bytes.
 * \param[in]  scaling       Factor for scaling source
 *
 * \see A1_Put, A1_Copy
 *
 * \ingroup DATA_TRANSFER
 */

int A1_GetAcc(int target,
              void* source_ptr,
              void* target_ptr,
              int bytes,
              A1_datatype_t a1_type,
              void* scaling);

/**
 * \brief Blocking copy of contiguous data from local memory to remote memory.
 *
 * \param[out] rc              The error code.
 * \param[in]  target          Rank of the remote process.
 * \param[in]  source_ptr      Starting address in the (local) source memory.
 * \param[in]  src_stride_ar   Array of stride distances at source in bytes.
 * \param[in]  target_ptr      Starting address in the (remote) target memory.
 * \param[in]  trg_stride_ar   Array of stride distances at target in bytes.
 * \param[in]  count           Block size in each dimension in bytes.
 * \param[in]  stride_levels   The number of levels of stride.
 *
 * \see A1_Put, A1_Get, A1_Copy, A1_PutAcc
 *
 * \ingroup DATA_TRANSFER
 */

int A1_GetAccS(int target,
               void* source_ptr,
               int *src_stride_ar,
               void* target_ptr,
               int *trg_stride_ar,
               int *count,
               int stride_levels,
               A1_datatype_t a1_type,
               void* scaling);

/**
 * \brief Blocking copy of contiguous data from remote memory to remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  source        Rank of the (remote) source process.
 * \param[in]  target        Rank of the (remote) target process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 *
 * \see A1_Put, A1_Get
 *
 * \ingroup DATA_TRANSFER
 */

int A1_Copy(int source,
            int target,
            void* source_ptr,
            void* target_ptr,
            int bytes);

/**
 * \brief Blocking accumulate of contiguous data from remote memory onto remote memory.
 *
 * \param[out] rc            The error code.
 * \param[in]  source        Rank of the (remote) source process.
 * \param[in]  target        Rank of the (remote) target process.
 * \param[in]  source_ptr    Starting address in the (remote) source memory.
 * \param[in]  target_ptr    Starting address in the (remote) target memory.
 * \param[in]  bytes         Amount of data to transfer in bytes.
 * \param[in]  a1_type       Amount of data to transfer in bytes.
 * \param[in]  scaling       Factor for scaling source
 *
 * \see A1_Put, A1_Get
 *
 * \ingroup DATA_TRANSFER
 */

int A1_CopyAcc(int source,
               int target,
               void* source_ptr,
               void* target_ptr,
               int bytes,
               A1_datatype_t a1_type,
               void* scaling);

/* FIXME: More API functions to come */

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - synchronization and completion         */
/*                                                                        */
/* ********************************************************************** */

/**
 * \brief On return, this call ensures that all processes within the entire group
 *        have reached this point in the program.
 *
 *        This operation is collective and blocking.
 *
 * \param[out] rc            The error code.
 * \param[in] group          Group of processes to synchronize.
 *
 * \see A1_Flush, A1_AllFlush, A1_Sync.
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Barrier_group(A1_group_t* group);

/**
 * \brief On return, this call ensures that all outstanding blocking put or accumulate
 *        operations are complete remotely within the entire group.
 *
 *        This operation is collective and blocking.  It has the effect of
 *        A1_Flush_group called from every process in the group followed by A1_Barrier_group.
 *
 * \param[out] rc            The error code.
 * \param[in] group          Group of processes to synchronize.
 *
 * \see A1_GlobalSync, A1_GroupBarrier, A1_Flush_group.
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Sync_group(A1_group_t* group);

/**
 * \brief On return, this call ensures that all blocking and non-blocking put
 *        and accumulate operations sent to the target process have completed remotely.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc            The error code.
 * \param[in]  proc          Rank of the remote process.
 *
 * \see A1_Flush_group, A1_Sync
 *
 * \ingroup COMPLETION
 */

int A1_Flush(int proc);

/**
 * \brief On return, this call ensures that all blocking and non-blocking put
 *        and accumulate operations have completed remotely at the processes given in the list.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc                The error code.
 * \param[in] count              Number of processes in vector.
 * \param[in] proc_list          Vector of processes to flush against.
 *
 * \see A1_Flush, A1_Flush_group
 *
 * \ingroup COMPLETION
 */

int A1_Flush_list(int count, int *proc_list);

/**
 * \brief On return, this call ensures that all blocking and non-blocking put
 *        and accumulate operations have completed remotely at the processes in the group.
 *
 *        This operation is local and blocking.
 *
 * \param[out] rc                The error code.
 * \param[in] count              Number of processes in vector.
 * \param[in] proc_list          List of processes to flush against.
 *
 * \see A1_Flush, A1_Sync
 *
 * \ingroup COMPLETION
 */

int A1_Flush_group(A1_group_t* group);

/**
 * \brief Blocks on completion of a non-blocking handle.
 *
 * \param[in] handle      Non-blocking handle upon which to be waited.
 *
 * \see A1_handle_t, A1_Wait_handle_list, A1_Test_handle
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Wait_handle(A1_handle_t handle);

/**
 * \brief Blocks on completion of all elements in a vector of non-blocking handles.
 *
 * \param[in] count        Number of handles in vector.
 * \param[in] handles      Vector of non-blocking handles upon which to be waited.
 *
 * \see A1_handle_t, A1_Wait_handle, A1_Test_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Wait_handle_list(int count, A1_handle_t* handles);

/**
 * \brief Blocks on completion of a non-blocking handle.
 *
 * \param[in]  handle        Non-blocking handle upon which to be waited.
 * \param[out] completed     Handle status.
 *
 * \see A1_handle_t, A1_Wait_handle, A1_Test_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Test_handle(A1_handle_t handle, A1_bool_t* completed);

/**
 * \brief Blocks on completion of all elements in a vector of non-blocking handles.
 *
 * \param[in]  count        Number of handles in vector.
 * \param[in]  handles      Vector of non-blocking handles upon which to be waited.
 * \param[out] completed    Vector of handle statuses.
 *
 * \see A1_handle_t, A1_Test_handle, A1_Wait_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Test_handle_list(int count,
                        A1_handle_t* handles,
                        A1_bool_t* *completed);

/**
 * \brief Resets a non-blocking handle.
 *
 * \param[in] handle      Non-blocking handle to be reset.
 *
 * \see A1_handle_t, A1_Reset_handle_list
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Reset_handle(A1_handle_t* handle);

/**
 * \brief Resets a non-blocking handle.
 *
 * \param[in]  count        Number of handles in vector.
 * \param[in] handle      Non-blocking handle to be reset.
 *
 * \see A1_handle_t, A1_Reset_handle
 *
 * \ingroup SYNCHRONIZATION
 */

int A1_Reset_handle_list(int count, A1_handle_t* handle);

/* ********************************************************************** */
/*                                                                        */
/*               A1 external API - many-to-many operations                */
/*                                                                        */
/* ********************************************************************** */

/**
 * \brief
 *
 * \param[in] group          Group of processes.
 *
 * \see
 *
 * \ingroup MANYTOMANY
 */

int A1_Broadcast(A1_group_t* group);

/* FIXME: More API functions to come */

/*! @} */

/* A1_VERSION is the version string. A1_NUMVERSION is the
 * numeric version that can be used in numeric comparisons.
 *
 * A1_VERSION uses the following format:
 * Version: [MAJ].[MIN].[REV][EXT][EXT_NUMBER]
 * Example: 1.0.7rc1 has
 *          MAJ = 1
 *          MIN = 0
 *          REV = 7
 *          EXT = rc
 *          EXT_NUMBER = 1
 *
 * A1_NUMVERSION will convert EXT to a format number:
 *          ALPHA (a) = 0
 *          BETA (b)  = 1
 *          RC (rc)   = 2
 *          PATCH (p) = 3
 * Regular releases are treated as patch 0
 *
 * Numeric version will have 1 digit for MAJ, 2 digits for MIN, 2
 * digits for REV, 1 digit for EXT and 2 digits for EXT_NUMBER. So,
 * 1.0.7rc1 will have the numeric version 10007201.
 */
#define A1_VERSION "@A1_VERSION@"
#define A1_NUMVERSION @A1_NUMVERSION@

#define A1_RELEASE_TYPE_ALPHA  0
#define A1_RELEASE_TYPE_BETA   1
#define A1_RELEASE_TYPE_RC     2
#define A1_RELEASE_TYPE_PATCH  3

#define A1_CALC_VERSION(MAJOR, MINOR, REVISION, TYPE, PATCH) \
    (((MAJOR) * 10000000) + ((MINOR) * 100000) + ((REVISION) * 1000) + ((TYPE) * 100) + (PATCH))

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* A1_H_INCLUDED */
